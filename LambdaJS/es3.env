let $global = ref { }

let @Object_prototype = ref { }

let @Function_prototype = ref { }

let @isRefComb = fun(f,e) .
  if typeof e === "location" then
    f(!e)
  else
    false



// Algorithm 9.9 of ECMA-262, 3rd ed.
let @toObject = fun(x) .
  if typeof x === "undefined" then
    throw ($makeException("TypeError", "toObject received undefined"))
  else if x === null then
    throw ($makeException("TypError", "toObject received null"))
  else if typeof x === "boolean" then
    ref { 
      "$proto": "$Boolean.prototype",
      "$class": "Boolean",
      "$value": x
    }
  else if typeof x === "number" then
    ref {
      "$proto": "$Number.prototype",
      "$class": "Number",
      "$value": x
    }
  else if typeof x === "string" then
    ref {
      "$proto": "$String.prototype",
      "$class": "String",
      "$value": x
    }
  else
    x

let $makeException = fun(name, msg) .
  @newDirect($global[name], ref  { "0": msg, "length": 1.0, "$isArgs": True })

let @newDirect = fun($constr, @argObj) .
  if typeof $constr === "location" && typeof (!$constr) === "object" &&
     typeof ((!$constr)["$code"]) === "lambda"  then
    // [[Construct]], 13.2.2 . it's always the same,
    // so no need to have it be a $constr field (like $call)
    let $protoField = !$constr["prototype"] in
    let $protoObj = if typeof $protoField === "location" && 
                       typeof (!$protoField) === "object" then
                      $protoField
                    else
                      @Object_prototype in
    let $newObj = ref { "$constructing": true,
                        "$class": "Object",
                        "$proto": $protoField } in
    let newResult = !$constr["$code"]($newObj, @argObj) in
      if typeof newResult === "location" && typeof(!newResult) === "object" then
        newResult
      else
        ($newObj := (delete (!$newObj)["$constructing"]);
         $newObj)
  else
    throw ($makeException("TypeError", "new not given a function"))
